\chapter{\label{ch:ch02}ПРАКТИЧЕСКАЯ ЧАСТЬ}

\section{Установка FLTK и выбор редактора кода}
\subsubsection{Установка FLTK}
\begin{enumerate}
    \item Чтобы установить FLTK для Python нужно в командной строке ввести команду:
    
    \textbf{pip install pyFltk}
   
    \item Чтобы импортировать FLTK в код нужно в коде написать строку:
    \begin{minted}[fontsize=\normalsize]{py}
        import fltk as fl
    \end{minted}
    
\end{enumerate}
\subsubsection{Выбор редактора кода}
Для выполнения работы я выбрал редактор кода Visual Studio Code. Это довольно хороший редактор. Удобен в использовании, 
имеет подсветку синтаксиса, технологию автодополнения.

\section{Создание главного окна и его наполнение}
\begin{itemize}
    \item Для создания главного окна создаем объект main\_window класса Fl\_Double\_Window
    \item Создаем кнопку для запуска/остановки процесса роста дендрита, кнопку быстрой постройки дендрита, кнопку вкл/выкл сетки на поле. Это будут соответственно объекты btn\_stop, btn\_bid, btn\_net класса Fl\_Button
    \item Создаем объект menu\_bar класса Fl\_Menu\_Bar - интерфейс меню
    \item Создаем группу объектов menuitems~\cite{docPyFl}, которая определяет пункты меню: Меню, Настройки, Помощь, О программе, Выход
\end{itemize}

\section{Функции кнопок}
Функции, вызываемые при нажатии на кнопки будут иметь подпись call\_. Для установки функции кнопки используется метод Fl\_Button.callback([название функции]).

\section{Создание дополнительных окон}
Каждое дополнительное окно будет являться объектом определенного класса. Нужно создать следующие классы: Window\_Setting, Window\_Help, Window\_About и соответственно объекты данных классов: window\_s, window\_h, window\_a. Атрибутами классов дополнительных окон являются кнопки, поля ввода, поля вывода. Данные атрибуты являются объектами классов Fl\_Button, Fl\_Value\_Input, Fl\_Multiline\_Output~\cite{docFl}.

\section{Создание констант, глобальных объектов и переменных}
Создаем константы:
\begin{itemize}
    \item MAIN\_WIN\_W = 800 и MAIN\_WIN\_H = 600 - ширина и высота главного окна;
    \item S\_MIN = 50, W\_MAX = MAIN\_WIN\_W - 10, H\_MAX - мин. и макс. размеры сторон поля;
    \item G\_MAX\_PAR - макс. возможное кол-во частиц;
    \item G\_MAX\_PS - макс. размер частицы
    \item INDENT\_WH - отступы поля
    \item SETTING\_DFL - настройки по умолчанию
\end{itemize}
Создаем следующие глобальные объекты и переменные:
\begin{itemize}
    \item particles - список, хранящий координаты частиц;
    \item part - текущая частица (которая движется);
    \item c\_p - кол-во обычных частиц;
    \item c\_pi - кол-во инверсных частиц;
    \item c\_tol - общее число частиц;
    \item p\_s - размер частицы;
    \item live - логическая. Определяет продолжать или закончить процесс роста дендрита;
    \item count - текущее кол-во частиц на поле;
    \item stop - логическая. Останавливает или продолжает процесс роста дендрита;
    \item exn - логическая. Определяет, активна ли функция расширение поля;
    \item bid\_prs - логическая. Управляет процессом быстрой постройки дендрита;
    \item y\_spn - координата \textit{y} изначального положения частицы;
    \item p - список, хранящий вероятности движения частицы;
    \item arr\_init - список, хранящий координаты \textit{x}, которые может иметь частица в изначальном положении;
    \item fid\_wh - список для хранения текущей ширины и высоты поля
    \item arr\_xy - двумерный список, хранящий нули и единицы. Нужен для проверки наличия частиц около текущей частицы;
    \item fid\_xy - правая и нижняя граница поля;
\end{itemize}

\section{Создание класса рисования}
Класс рисования будет называться Drawing~\cite{expleDrw}. У данного класса есть функция draw, которая будет выполнять рисование. 

Работа данной функции: сначала вызывается функция fl\_rectf(self.x(), self.y(), self.w(), self.h(), FL\_GRAY), которая создает прямоугольную область рисования: первые два аргумента - это координаты левого верхнего угла области, следующие два аргумента - это ширина и высота области, и последний аргумент - это цвет области. Далее на этой области происходит рисование текущей частицы, которая движется. Затем отрисовываются частицы, которые уже приклеены на поле. Если включено отображение сетки, то она тоже будет отрисована. Для перерисовки вызывается функция redraw(). 

\begin{figure}[H]
    \centering
    \includesvg[width=1\textwidth]{svg/dend_draw_class.svg}
    \caption{Блок-схема функции draw.}
\end{figure}

\section{Создание класса частицы}
Класс частицы будет называться Particle. Атрибуты данного класса: x - координата x; y - координата y; tch - определяет коснулась ли частица чего-либо; type - тип частицы. Данный класс имеет функцию move(), отвечающую за движение частицы и функцию inv(), отвечающую за инверсию (для инверсной частицы).
Работа функции inv: функция работает только для инверсной частицы. Если произошло касание с какой-либо другой частицей, то создается список mass, который содержит координаты соседних клеток поля. Далее происходит проход по этому списку циклом for: проверяется значение ячейки списка arr\_xy с индексами соответствующими координатам из списка mass. Если значение 0, то оно становится равным 1 и в список particles добавляются координаты из списка mass, иначе - равным 0 и из particles удаляются координаты из mass.

%\begin{figure}[H]
%    \centering
%    \includegraphics[width=1\textwidth]{images/dend_part_move.png}
%    \caption{Блок-схема функции move.}
%\end{figure}

\begin{figure}[H]
    \centering
    \includesvg[width=1\textwidth]{svg/dend_part_move.svg}
    \caption{Блок-схема функции move.}
\end{figure}

\section{Создание основных функций}
\subsubsection{Функция core}
Она управляет частицами: создает их, приводит их в движение. Данная функция работает следующим образом: если у текущей частицы произошло касание, то вычисляются вероятности выпадения обычной и инверсной частицы, далее создается частица тип которой выбирается случайно с учетом вычисленных ранее вероятностей. Далее запускается функция движения частицы move. Если частица коснулась чего-либо, то счетчик частиц (count) увеличивается на 1, в список particles добавляются координаты частицы, которая коснулась. В списке arr\_xy элемент с индексами соответствующими координатам текущей частицы принимает значение 1. Вызывается функция инверсии inv(). Далее проверяется является ли частица, у которой произошло касание, последней частицей. Если да, то процесс роста дендрита прекращается (live становится равным False).

\begin{figure}[H]
    \centering
    \includesvg[width=1\textwidth]{svg/dend_core_v2.svg}
    \caption{Блок-схема функции core.}
\end{figure}

\subsubsection{Функция расширения}
Данная функция используется в режиме моделирования с расширением поля. Работа данной функции: проверяется, находится ли координата \textit{y} текущей частицы слишком близко к линии создания частиц (y\_spn). Если находится, то поле увеличивается по высоте к низу окна.
Для этого происходит сдвиг координат \textit{y} всех частиц на поле на одну клетку вниз, также изменяются и расположения единиц в списке arr\_xy.
\subsubsection{Функция повтора}
Сначала проверяется, запущен ли процесс быстрой постройки и если нет, то вызывается функция redraw(), а затем - функция repeat\_timeout(), которая сделает шаг моделирования по истечении небольшого промежутка времени~\cite{expleGit}


